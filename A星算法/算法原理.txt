其实A星算法不是一个新鲜的东西，之前论坛也有帖子，使用递归解法进行A星寻路，原帖：http://bbs.anjian.com/thread-255360-1-1.html （作者：182282727）

递归的代码量惊人的短，只有20行，但是理解起来相当的有难度，至少我是看了好几天。

所以我想，如果不用递归，而用传统的循环解法来做A星，行不行呢？

循环解A星，百度有很多文章，有详细的算法描述，深入浅出，还是不难理解的，我这里总结下：

1、首先把整个地图，划分为若干个小块，通常最简单的小块，全部都是正方形，这些小块，有些是障碍，有些是通道。我们把小块都称为节点。

2、每一个表示通道的节点，都具有如下的6个属性
   ①自己的横坐标
   ②自己的纵坐标
   ③自己离起点的距离
   ④自己离终点的距离
   ⑤父节点的横坐标
   ⑥父节点的纵坐标
   ⑦F值，这个F值，就是属性③和属性④相加得到的和，因为可以计算，所以我们暂时不作为一个单独的属性来记录，而是作为描述使用
①②属性很好理解，不解释了；③属性也很简单，代表的是从起点进过多少步到达此节点；④属性，由于在获取到完整的路径之前，你并不知道需要经过多少步会达到终点，
所以这个属性实际上是一个估算值，估算的方法也有很多，对整个A星的计算效率也会有影响，我们暂时使用最简单的估算方法：无视障碍，走直角线路到达终点的距离(注意，不走斜线)。
⑤⑥属性解释下，这2个坐标是指的你从哪一个节点到达的当前节点，也就是对应的上一个节点。这2个属性可以确保在最终你能找到最短路径。

3、寻路过程中我们会用到3个列表，这3个表，通常被设计为一维数组
   开放列表。我们在寻路过程中，认为可能符合要求的点，就添加到开放列表中
   探索列表。我们对开放列表里面所有的节点进行判断，符合要求的，放到这个表中
   路径列表。从探索列表里面所有符合要求的节点中，找出的最短路径的节点

4、寻路的步骤
   a）将起点放入探索列表，定义为当前节点。
   b）检测当前节点周围的节点（本例中进行4方向检测），这些周围的点，称为临时节点。如果该临时节点是通道，那么将其加入开放列表。

   将 c 和 d 这2步，作为循环来处理

   c）从开放列表中，选取一个F值最小的节点（就是属性③和属性④相加最小，代表着这个节点在当前看来是符合最短路径的要求的），将它从开放列表中去掉，加入到探索列表中。
		如果开放列表中，有多个节点的F是相等的，那么我们选取属性③比较小的节点（因为距离起点的值是可靠的，而距离终点的值是估算的），如果属性③仍然相等，
		那么我们选取最新加入到开放列表的那个节点（这一步在大地图的时候，会增加速度）。
   d）将这个选出来的点，再次作为当前节点，开始检测它周围的4个临时节点，从这个时候开始，如果临时节点是障碍，我们就舍弃；而如果是通道，我们也不能像第 b）步 那样直接
		把这个临时节点加入到开放列表。我们还需要判断：第一，该临时节点是否已经被加入了探索列表？如果是，那么舍弃它；第二，该临时节点是否已经在开放列表中？如果是，
		那么代表这个临时节点和保存在开放列表中的节点，属性①②相同，但属性③⑤⑥必定不完全相同（因为是经由不同的父节点进行检测，这一点需要理解），于是我们对临时节
		点和保存在开放列表中的节点（属性①②相同的这2个节点）进行属性③的对比（这2个点的属性④是相同的），如果临时节点的属性③比较小，那么我们就将临时节点的信息，
		替换掉已经保存在开放列表中那个节点的所有信息，否则我们就舍弃这个临时节点；第三，该临时节点是个通道，没有保存在探索列表中，也没有在开放列表中，那么我们把这个临时节点加入到开放列表。

   进行 c-d 的循环   

   e）循环在何时结束？很简单，当终点也被加入到了探索列表中，代表着我们的探索已经完成，这个时候跳出循环

   f）循环结束之后，我们获得了一个比较庞大的探索列表，里面包含了我们所有探索过的节点，其中，第一个是起点，最后一个是终点。于是我们从终点开始，检测其父节点的坐标，
		然后再检测父节点的父节点，最终我们得到了一条从终点指向起点的最短路径。



整个A星算法看起来很复杂，但是如果你理解了你会发现其实每一步都不复杂，只不过当地图很大的时候，循环的次数可能很多，而计算机就是用来做这个的，当我们确认算法没有漏洞的时候，
不管有多么庞大的数据，最终都会得到一个正确的结果。